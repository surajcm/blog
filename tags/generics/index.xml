<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Generics on Explore my world</title><link>https://surajcm.github.io/blog/tags/generics/</link><description>Recent content in Generics on Explore my world</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Tue, 01 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://surajcm.github.io/blog/tags/generics/index.xml" rel="self" type="application/rss+xml"/><item><title>Understanding Java Generics: An In-Depth Guide</title><link>https://surajcm.github.io/blog/post/java-generics-notes/</link><pubDate>Tue, 01 Mar 2022 00:00:00 +0000</pubDate><guid>https://surajcm.github.io/blog/post/java-generics-notes/</guid><description>
&lt;h3 id="introduction">Introduction:&lt;/h3>
&lt;p>In the realm of Java programming, ensuring type safety and crafting reusable code profoundly influence software reliability. Consider an &lt;code>ArrayList&lt;/code> intended for integers but lacking generics; it permits various object types, leading to runtime errors when unintended types are retrieved. This absence of strict type checking often results in elusive errors, complicating code stability. However, Java's introduction of generics offers a solution, infusing type safety into classes and collections.&lt;/p></description></item></channel></rss>